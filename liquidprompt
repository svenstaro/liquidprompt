################################################################################
# LIQUID PROMPT
# An intelligent and non-intrusive prompt for Bash and zsh
################################################################################

# Licensed under the AGPL version 3
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# See the README.md file for a summary of features.

if test -n "${BASH_VERSION-}"; then
    # Check for recent enough version of bash.
    if (( ${BASH_VERSINFO[0]:-0} < 3 || ( ${BASH_VERSINFO[0]:-0} == 3 && ${BASH_VERSINFO[1]:-0} < 2 ) )); then
        echo "liquidprompt: Bash version $BASH_VERSION not supported" 2>&1
        return
    fi

    _LP_SHELL_bash=true
    _LP_SHELL_zsh=false
    _LP_OPEN_ESC="\["
    _LP_CLOSE_ESC="\]"

    _LP_USER_SYMBOL="\u"
    _LP_HOST_SYMBOL="\h"
    _LP_FQDN_SYMBOL="\H"
    _LP_TIME_SYMBOL="\t"
    _LP_MARK_SYMBOL='\$'
    _LP_PWD_SYMBOL="\\w"
    _LP_DIR_SYMBOL="\\W"

    _LP_FIRST_INDEX=0
    _LP_PERCENT='%'    # must be escaped on zsh
    _LP_BACKSLASH='\\' # must be escaped on bash

    # Sed expression using extended regexp to match terminal
    # escape sequences with their wrappers
    _LP_CLEAN_ESC='\\\[([^\]+|\\[^]])*\\\]'

    # Escape the given strings
    # Must be used for all strings injected in PS1 that may comes from remote sources,
    # like $PWD, VCS branch names...
    _lp_escape()
    {
        ret="${1//\\/\\\\}"
    }
elif test -n "${ZSH_VERSION-}" ; then
    _LP_SHELL_bash=false
    _LP_SHELL_zsh=true
    _LP_OPEN_ESC="%{"
    _LP_CLOSE_ESC="%}"

    _LP_USER_SYMBOL="%n"
    _LP_HOST_SYMBOL="%m"
    _LP_FQDN_SYMBOL="%M"
    _LP_TIME_SYMBOL="%*"
    _LP_MARK_SYMBOL='%(!.#.%%)'
    _LP_PWD_SYMBOL="%~"
    _LP_DIR_SYMBOL="%1~"

    _LP_FIRST_INDEX=1
    _LP_PERCENT='%%'
    _LP_BACKSLASH="\\"

    _LP_CLEAN_ESC='%\{([^%]+|%[^}])*%\}'

    _lp_escape()
    {
        local arg="${1//\\/\\\\}"
        ret="${arg//\%/$_LP_PERCENT}"
    }
else
    echo "liquidprompt: shell not supported" >&2
    return
fi

# Count the number of lines in the input string. A faster subsitute for 'wc -l'
#   input: text; a single string of input
#   return: $count
_lp_line_count() {
  local var="${1//[!$'\n']/}"
  count=${#var}
}

###############
# OS specific #
###############

# LP_OS detection, default to Linux
case $(uname) in
    FreeBSD)   LP_OS=FreeBSD ;;
    DragonFly) LP_OS=FreeBSD ;;
    OpenBSD)   LP_OS=OpenBSD ;;
    Darwin)    LP_OS=Darwin  ;;
    SunOS)     LP_OS=SunOS   ;;
    *)         LP_OS=Linux   ;;
esac

# Get cpu count
case "$LP_OS" in
    Linux)   _lp_CPUNUM=$( nproc 2>/dev/null || \grep -c '^[Pp]rocessor' /proc/cpuinfo ) ;;
    FreeBSD|Darwin|OpenBSD) _lp_CPUNUM=$( sysctl -n hw.ncpu ) ;;
    SunOS)   _lp_CPUNUM=$( kstat -m cpu_info | \grep -c "module: cpu_info" ) ;;
esac

# Extended regexp patterns for sed
# GNU/BSD sed
_LP_SED_EXTENDED=r
[[ "$LP_OS" = Darwin ]] && _LP_SED_EXTENDED=E


# get current load
case "$LP_OS" in
    Linux)
        _lp_cpu_load () {
            local eol IFS=$' \t'
            read lp_cpu_load eol < /proc/loadavg
        }
        ;;
    FreeBSD|Darwin|OpenBSD)
        _lp_cpu_load () {
            local bol eol IFS=$' \t'
            # If you have problems with syntax coloring due to the following
            # line, do this: ln -s liquidprompt liquidprompt.bash
            # and edit liquidprompt.bash
            read bol lp_cpu_load eol <<<"$( LC_ALL=C sysctl -n vm.loadavg )"
        }
        ;;
    SunOS)
        _lp_cpu_load () {
            lp_cpu_load="$( LC_ALL=C uptime | sed 's/.*load average: *\([0-9.]*\).*/\1/' )"
        }
esac


#################
# CONFIGURATION #
#################

# The following code is run just once. But it is encapsulated in a function
# to benefit of 'local' variables.
#
# What we do here:
# 1. Setup variables that can be used by the user: the "API" of Liquid Prompt
#    for config/theme. Those variables are local to the function.
#    In practice, this is only color variables.
# 2. Setup default values
# 3. Load the configuration
_lp_source_config()
{

    # TermInfo feature detection
    typeset -a af_colors ab_colors
    local af_color ab_color

    # TODO handle this case better. With no colors, no need for any escaping
    if ! command -v tput >/dev/null; then
        echo "liquidprompt: 'tput' not available; will not be able to format terminal" >&2
    fi

    local ti_sgr0="$( { tput sgr0 || tput me ; } 2>/dev/null )"
    local ti_bold="$( { tput bold || tput md ; } 2>/dev/null )"
    if tput setaf 0 >/dev/null 2>&1; then
        foreground_color() { af_color="${af_colors[$1+1]:=$(tput setaf $1)}"; }
    elif tput AF 0 >/dev/null 2>&1; then
        # FreeBSD
        foreground_color() { af_color="${af_colors[$1+1]:=$(tput AF $1)}"; }
    elif tput AF 0 0 0 >/dev/null 2>&1; then
        # OpenBSD
        foreground_color() { af_color="${af_colors[$1+1]:=$(tput AF $1 0 0)}"; }
    else
        echo "liquidprompt: terminal $TERM does not support foreground colors" >&2
        foreground_color() { : ; }
    fi
    if tput setab 0 >/dev/null 2>&1; then
        background_color() { ab_color="${ab_colors[$1+1]:=$(tput setab $1)}"; }
    elif tput AB 0 >/dev/null 2>&1; then
        # FreeBSD
        background_color() { ab_color="${ab_colors[$1+1]:=$(tput AB $1)}"; }
    elif tput AB 0 0 0 >/dev/null 2>&1; then
        # OpenBSD
        background_color() { ab_color="${ab_colors[$1+1]:=$(tput AB $1 0 0)}"; }
    else
        echo "liquidprompt: terminal $TERM does not support background colors" >&2
        background_color() { : ; }
    fi

    # Colors: variables are local so they will have a value only
    # during config loading and will not conflict with other values
    # with the same names defined by the user outside the config.
    local BOLD="${_LP_OPEN_ESC}${ti_bold}${_LP_CLOSE_ESC}"

    # Foreground colors
    foreground_color 0
    local BLACK="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_GRAY="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 1
    local RED="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_RED="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"
    foreground_color 0
    background_color 1
    local WARN_RED="${_LP_OPEN_ESC}${af_color}${ab_color}${_LP_CLOSE_ESC}"
    foreground_color 7
    local CRIT_RED="${_LP_OPEN_ESC}${ti_bold}${af_color}${ab_color}${_LP_CLOSE_ESC}"
    foreground_color 3
    local DANGER_RED="${_LP_OPEN_ESC}${ti_bold}${af_color}${ab_color}${_LP_CLOSE_ESC}"

    foreground_color 2
    local GREEN="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_GREEN="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 3
    local YELLOW="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_YELLOW="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 4
    local BLUE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_BLUE="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 5
    local PURPLE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local MAGENTA="${PURPLE}"
    local PINK="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_PURPLE="${PINK}"
    local BOLD_MAGENTA="${PINK}"

    foreground_color 6
    local CYAN="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_CYAN="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    foreground_color 7
    local WHITE="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"
    local BOLD_WHITE="${_LP_OPEN_ESC}${ti_bold}${af_color}${_LP_CLOSE_ESC}"

    # NO_COL is special: it will be used at runtime, not just during config loading
    NO_COL="${_LP_OPEN_ESC}${ti_sgr0}${_LP_CLOSE_ESC}"

    # compute the hash of the hostname
    # and get the corresponding number in [1-6] (red,green,yellow,blue,purple or cyan)
    # FIXME Add more formats (bold? 256 colors?)
    # cksum is separated with tab on SunOS, space on others
    local cksum="$(hostname | cksum)"
    foreground_color $(( 1 + ${cksum%%[$' \t']*} % 6 ))
    LP_COLOR_HOST_HASH="${_LP_OPEN_ESC}${af_color}${_LP_CLOSE_ESC}"

    unset -f foreground_color background_color


    # Default values (globals)
    LP_BATTERY_THRESHOLD=${LP_BATTERY_THRESHOLD:-75}
    LP_LOAD_THRESHOLD=${LP_LOAD_THRESHOLD:-60}
    LP_TEMP_THRESHOLD=${LP_TEMP_THRESHOLD:-60}
    LP_RUNTIME_THRESHOLD=${LP_RUNTIME_THRESHOLD:-2}
    LP_RUNTIME_BELL_THRESHOLD=${LP_RUNTIME_BELL_THRESHOLD:-10}
    LP_PATH_LENGTH=${LP_PATH_LENGTH:-35}
    LP_PATH_KEEP=${LP_PATH_KEEP:-2}
    LP_PATH_DEFAULT="${LP_PATH_DEFAULT:-$_LP_PWD_SYMBOL}"
    LP_HOSTNAME_ALWAYS=${LP_HOSTNAME_ALWAYS:-0}
    LP_USER_ALWAYS=${LP_USER_ALWAYS:-1}
    LP_PERCENTS_ALWAYS=${LP_PERCENTS_ALWAYS:-1}
    LP_PS1=${LP_PS1:-""}
    LP_PS1_PREFIX=${LP_PS1_PREFIX:-""}
    LP_PS1_POSTFIX=${LP_PS1_POSTFIX:-""}

    LP_ENABLE_PERM=${LP_ENABLE_PERM:-1}
    LP_ENABLE_SHORTEN_PATH=${LP_ENABLE_SHORTEN_PATH:-1}
    LP_ENABLE_PROXY=${LP_ENABLE_PROXY:-1}
    LP_ENABLE_TEMP=${LP_ENABLE_TEMP:-1}
    LP_ENABLE_JOBS=${LP_ENABLE_JOBS:-1}
    LP_ENABLE_LOAD=${LP_ENABLE_LOAD:-1}
    LP_ENABLE_BATT=${LP_ENABLE_BATT:-1}
    LP_ENABLE_GIT=${LP_ENABLE_GIT:-1}
    LP_ENABLE_SVN=${LP_ENABLE_SVN:-1}
    LP_ENABLE_VCSH=${LP_ENABLE_VCSH:-1}
    LP_ENABLE_FOSSIL=${LP_ENABLE_FOSSIL:-1}
    LP_ENABLE_HG=${LP_ENABLE_HG:-1}
    LP_ENABLE_BZR=${LP_ENABLE_BZR:-1}
    LP_ENABLE_TIME=${LP_ENABLE_TIME:-0}
    LP_ENABLE_RUNTIME=${LP_ENABLE_RUNTIME:-1}
    LP_ENABLE_RUNTIME_BELL=${LP_ENABLE_RUNTIME_BELL:-0}
    LP_ENABLE_VIRTUALENV=${LP_ENABLE_VIRTUALENV:-1}
    LP_ENABLE_SCLS=${LP_ENABLE_SCLS:-1}
    LP_ENABLE_VCS_ROOT=${LP_ENABLE_VCS_ROOT:-0}
    LP_ENABLE_TITLE=${LP_ENABLE_TITLE:-0}
    LP_ENABLE_SCREEN_TITLE=${LP_ENABLE_SCREEN_TITLE:-0}
    LP_ENABLE_SSH_COLORS=${LP_ENABLE_SSH_COLORS:-0}
    LP_ENABLE_FQDN=${LP_ENABLE_FQDN:-0}
    # LP_DISABLED_VCS_PATH="${LP_DISABLED_VCS_PATH}"
    LP_ENABLE_SUDO=${LP_ENABLE_SUDO:-0}

    LP_MARK_DEFAULT="${LP_MARK_DEFAULT:-$_LP_MARK_SYMBOL}"
    LP_MARK_BATTERY="${LP_MARK_BATTERY:-"⌁"}"
    LP_MARK_ADAPTER="${LP_MARK_ADAPTER:-"⏚"}"
    LP_MARK_LOAD="${LP_MARK_LOAD:-"⌂"}"
    LP_MARK_TEMP="${LP_MARK_TEMP:-"θ"}"
    LP_MARK_PROXY="${LP_MARK_PROXY:-"↥"}"
    LP_MARK_HG="${LP_MARK_HG:-"☿"}"
    LP_MARK_SVN="${LP_MARK_SVN:-"‡"}"
    LP_MARK_GIT="${LP_MARK_GIT:-"±"}"
    LP_MARK_VCSH="${LP_MARK_VCSH:-"|"}"
    LP_MARK_FOSSIL="${LP_MARK_FOSSIL:-"⌘"}"
    LP_MARK_BZR="${LP_MARK_BZR:-"⚯"}"
    LP_MARK_DISABLED="${LP_MARK_DISABLED:-"⌀"}"
    LP_MARK_UNTRACKED="${LP_MARK_UNTRACKED:-"*"}"
    LP_MARK_STASH="${LP_MARK_STASH:-"+"}"
    LP_MARK_BRACKET_OPEN="${LP_MARK_BRACKET_OPEN:-"["}"
    LP_MARK_BRACKET_CLOSE="${LP_MARK_BRACKET_CLOSE:-"]"}"
    LP_MARK_SHORTEN_PATH="${LP_MARK_SHORTEN_PATH:-" … "}"
    LP_MARK_PREFIX="${LP_MARK_PREFIX:-" "}"
    LP_MARK_PERM="${LP_MARK_PERM:-":"}"

    LP_COLOR_PATH=${LP_COLOR_PATH:-$BOLD}
    LP_COLOR_PATH_ROOT=${LP_COLOR_PATH_ROOT:-$BOLD_YELLOW}
    LP_COLOR_PROXY=${LP_COLOR_PROXY:-$BOLD_BLUE}
    LP_COLOR_JOB_D=${LP_COLOR_JOB_D:-$YELLOW}
    LP_COLOR_JOB_R=${LP_COLOR_JOB_R:-$BOLD_YELLOW}
    LP_COLOR_JOB_Z=${LP_COLOR_JOB_Z:-$BOLD_YELLOW}
    LP_COLOR_ERR=${LP_COLOR_ERR:-$PURPLE}
    LP_COLOR_MARK=${LP_COLOR_MARK:-$BOLD}
    LP_COLOR_MARK_ROOT=${LP_COLOR_MARK_ROOT:-$BOLD_RED}
    LP_COLOR_MARK_SUDO=${LP_COLOR_MARK_SUDO:-$LP_COLOR_MARK_ROOT}
    LP_COLOR_USER_LOGGED=${LP_COLOR_USER_LOGGED:-""}
    LP_COLOR_USER_ALT=${LP_COLOR_USER_ALT:-$BOLD}
    LP_COLOR_USER_ROOT=${LP_COLOR_USER_ROOT:-$BOLD_YELLOW}
    LP_COLOR_HOST=${LP_COLOR_HOST:-""}
    LP_COLOR_SSH=${LP_COLOR_SSH:-$BLUE}
    LP_COLOR_SU=${LP_COLOR_SU:-$BOLD_YELLOW}
    LP_COLOR_TELNET=${LP_COLOR_TELNET:-$WARN_RED}
    LP_COLOR_X11_ON=${LP_COLOR_X11_ON:-$GREEN}
    LP_COLOR_X11_OFF=${LP_COLOR_X11_OFF:-$YELLOW}
    LP_COLOR_WRITE=${LP_COLOR_WRITE:-$GREEN}
    LP_COLOR_NOWRITE=${LP_COLOR_NOWRITE:-$RED}
    LP_COLOR_UP=${LP_COLOR_UP:-$GREEN}
    LP_COLOR_COMMITS=${LP_COLOR_COMMITS:-$YELLOW}
    LP_COLOR_COMMITS_BEHIND=${LP_COLOR_COMMITS_BEHIND:-$BOLD_RED}
    LP_COLOR_CHANGES=${LP_COLOR_CHANGES:-$RED}
    LP_COLOR_DIFF=${LP_COLOR_DIFF:-$PURPLE}
    LP_COLOR_CHARGING_ABOVE=${LP_COLOR_CHARGING_ABOVE:-$GREEN}
    LP_COLOR_CHARGING_UNDER=${LP_COLOR_CHARGING_UNDER:-$YELLOW}
    LP_COLOR_DISCHARGING_ABOVE=${LP_COLOR_DISCHARGING_ABOVE:-$YELLOW}
    LP_COLOR_DISCHARGING_UNDER=${LP_COLOR_DISCHARGING_UNDER:-$RED}
    LP_COLOR_TIME=${LP_COLOR_TIME:-$BLUE}
    LP_COLOR_IN_MULTIPLEXER=${LP_COLOR_IN_MULTIPLEXER:-$BOLD_BLUE}
    LP_COLOR_RUNTIME=${LP_COLOR_RUNTIME:-$YELLOW}
    LP_COLOR_VIRTUALENV=${LP_COLOR_VIRTUALENV:-$CYAN}

    if [[ -z "${LP_COLORMAP-}" ]]; then
        LP_COLORMAP=(
            ""               # 0
            "$GREEN"         # 1
            "$BOLD_GREEN"    # 2
            "$YELLOW"        # 3
            "$BOLD_YELLOW"   # 4
            "$RED"           # 5
            "$BOLD_RED"      # 6
            "$WARN_RED"      # 7
            "$CRIT_RED"      # 8
            "$DANGER_RED"    # 9
        )
    fi

    # Debugging flags
    LP_DEBUG_TIME=${LP_DEBUG_TIME:-0}


    # Default config file may be the XDG standard ~/.config/liquidpromptrc,
    # but heirloom dotfile has priority.
    if [[ -f "$HOME/.liquidpromptrc" ]]; then
        source "$HOME/.liquidpromptrc"
    else
        local dir
        for dir in "${XDG_CONFIG_HOME:-"$HOME/.config"}" "${XDG_CONFIG_DIRS:-/etc/xdg}" "/etc"; do
            if [[ -f "$dir/liquidpromptrc" ]]; then
                source "$dir/liquidpromptrc"
                break
            fi
        done
    fi
}

typeset -i _LP_ENABLE_DETACHED_SESSIONS _LP_ENABLE_SCREEN _LP_ENABLE_TMUX

lp_activate() {
    if $_LP_SHELL_bash; then
        # Disable the DEBUG trap used by the RUNTIME feature
        # (in case we are reloading LP in the same shell after disabling
        # the feature in .liquidpromptrc)
        [[ -n "${LP_ENABLE_RUNTIME-}" ]] && trap - DEBUG
    else # zsh
        # For ZSH, autoload required functions
        autoload -Uz add-zsh-hook

        # Disable previous hooks as options that set them
        # may have changed
        {
            add-zsh-hook -d precmd  _lp_set_prompt
            add-zsh-hook -d preexec _lp_runtime_before
            add-zsh-hook -d precmd  _lp_runtime_after
        } >/dev/null
    fi

    _lp_source_config

    # Disable feature if the tool is not installed
    _lp_require_tool()
    {
        (( LP_ENABLE_$1 )) && { command -v $2 >/dev/null || eval LP_ENABLE_$1=0 ; }
    }

    _lp_require_tool GIT git
    _lp_require_tool SVN svn
    _lp_require_tool FOSSIL fossil
    _lp_require_tool HG hg
    _lp_require_tool BZR bzr

    LP_ENABLED_VCSS=()
    (( LP_ENABLE_GIT )) && LP_ENABLED_VCSS+=(git)
    (( LP_ENABLE_SVN )) && LP_ENABLED_VCSS+=(svn)
    (( LP_ENABLE_HG )) && LP_ENABLED_VCSS+=(hg)
    (( LP_ENABLE_BZR )) && LP_ENABLED_VCSS+=(bzr)

    if [[ "$LP_OS" = Darwin ]]; then
        _lp_require_tool BATT pmset
    else
        _lp_require_tool BATT acpi
    fi

    unset -f _lp_require_tool

    if (( LP_ENABLE_JOBS )); then
        command -v screen >/dev/null ; _LP_ENABLE_SCREEN=!$?
        command -v tmux >/dev/null   ; _LP_ENABLE_TMUX=!$?
        (( _LP_ENABLE_DETACHED_SESSIONS = ( _LP_ENABLE_SCREEN || _LP_ENABLE_TMUX ) ))
    fi

    # Use standard path symbols inside Midnight Commander
    [[ -n "${MC_SID-}" ]] && LP_ENABLE_SHORTEN_PATH=0

    # If we are running in a terminal multiplexer, brackets are colored
    if [[ "$TERM" == screen* || -n ${TMUX-} ]]; then
        LP_BRACKET_OPEN="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_OPEN}${NO_COL}"
        LP_BRACKET_CLOSE="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_CLOSE}${NO_COL}"
        (( LP_ENABLE_TITLE = LP_ENABLE_TITLE && LP_ENABLE_SCREEN_TITLE ))
        LP_TITLE_OPEN="$(printf '\033k')"
        # "\e\" but on bash \ must be escaped
        LP_TITLE_CLOSE="$(printf '\033%s' "$_LP_BACKSLASH")"
    else
        LP_BRACKET_OPEN="${LP_MARK_BRACKET_OPEN}"
        LP_BRACKET_CLOSE="${LP_MARK_BRACKET_CLOSE}"
        LP_TITLE_OPEN="$(printf '\e]0;')"
        LP_TITLE_CLOSE="$(printf '\a')"
    fi

    [[ "_$TERM" == _linux* ]] && LP_ENABLE_TITLE=0

    # update_terminal_cwd is a shell function available on MacOS X Lion that
    # will update an icon of the directory displayed in the title of the terminal
    # window.
    # See http://hints.macworld.com/article.php?story=20110722211753852
    if [[ "${TERM_PROGRAM-}" == Apple_Terminal ]] && command -v update_terminal_cwd >/dev/null; then
        _LP_TERM_UPDATE_DIR=update_terminal_cwd
        # Remove "update_terminal_cwd; " that has been add by Apple in /et/bashrc.
        # See issue #196
        PROMPT_COMMAND="${PROMPT_COMMAND//update_terminal_cwd; /}"
    else
        _LP_TERM_UPDATE_DIR=:
    fi

    # Default value for LP_PERM when LP_ENABLE_PERM is 0
    LP_PERM=${LP_MARK_PERM}   # without color

    # Same as bash '\l', but inlined as a constant as the value will not change
    # during the shell's life
    LP_TTYN="$(basename -- "$(tty)" 2>/dev/null)"


    ###############
    # Who are we? #
    ###############
    command -v _lp_sudo_check >/dev/null && unset -f _lp_sudo_check

    # Yellow for root, bold if the user is not the login one, else no color.
    if (( EUID != 0 )); then  # if user is not root
        # if user is not login user
        if [[ "${USER}" != "$(logname 2>/dev/null || echo "$LOGNAME")" ]]; then
            LP_USER="${LP_COLOR_USER_ALT}${_LP_USER_SYMBOL}${NO_COL}"
        elif (( LP_USER_ALWAYS )); then
            LP_USER="${LP_COLOR_USER_LOGGED}${_LP_USER_SYMBOL}${NO_COL}"
        else
            LP_USER=""
        fi
        # "sudo -n" is only supported from sudo 1.7.0
        if (( LP_ENABLE_SUDO )) \
                && command -v sudo >/dev/null \
                && LC_MESSAGES=C sudo -V | GREP_OPTIONS="" \grep -qE '^Sudo version (1(\.([789]\.|[1-9][0-9])|[0-9])|[2-9])'
        then
            LP_COLOR_MARK_NO_SUDO="$LP_COLOR_MARK"
            # Test the code with the commands:
            #   sudo id   # sudo, enter your credentials
            #   sudo -K   # revoke your credentials
            _lp_sudo_check()
            {
                if sudo -n true 2>/dev/null; then
                    LP_COLOR_MARK=$LP_COLOR_MARK_SUDO
                else
                    LP_COLOR_MARK=$LP_COLOR_MARK_NO_SUDO
                fi
            }
        fi
    else # root!
        LP_USER="${LP_COLOR_USER_ROOT}${_LP_USER_SYMBOL}${NO_COL}"
        LP_COLOR_MARK="${LP_COLOR_MARK_ROOT}"
        LP_COLOR_PATH="${LP_COLOR_PATH_ROOT}"
        # Disable VCS info for all paths
        if (( ! LP_ENABLE_VCS_ROOT )); then
            LP_DISABLED_VCS_PATH=/
            LP_MARK_DISABLED="$LP_MARK_DEFAULT"
        fi
    fi

    # Empty _lp_sudo_check if root or sudo disabled
    if ! command -v _lp_sudo_check >/dev/null; then
        _lp_sudo_check() { :; }
    fi


    #################
    # Where are we? #
    #################

    lp_hostname

    if (( LP_ENABLE_SHORTEN_PATH )); then
        if (( LP_PATH_KEEP == -1 )); then
            # _lp_shorten_path becomes a noop
            _lp_shorten_path()
            {
                :
            }
            # Will never change
            LP_PWD="${LP_COLOR_PATH}${_LP_DIR_SYMBOL}$NO_COL"
        fi
    else
        # Will never change
        LP_PWD="${LP_COLOR_PATH}${LP_PATH_DEFAULT}$NO_COL"

        if $_LP_SHELL_bash && [[ -n "$PROMPT_DIRTRIM" ]]; then
            unset -f _lp_shorten_path
            alias _lp_shorten_path=_lp_set_dirtrim
        fi
    fi

    _LP_RUNTIME_LAST_SECONDS=$SECONDS

    if (( LP_ENABLE_RUNTIME || LP_ENABLE_RUNTIME_BELL)); then
        if $_LP_SHELL_zsh; then
            add-zsh-hook preexec _lp_runtime_before
            add-zsh-hook precmd  _lp_runtime_after
        else
            _LP_AT_PROMPT=0
            # _lp_runtime_before gets called just before bash executes a command,
            # including $PROMPT_COMMAND
            # Pass $_ to this call, because it sets $_ to what it already was
            trap '_lp_runtime_before "$_"' DEBUG
        fi
    fi

    # Try each _lp_temp method
    # If no function worked, disable the feature
    _lp_temp_detect acpi sensors || LP_ENABLE_TEMP=0
}

lp_hostname() {
    # Put the hostname if not locally connected
    # color it in cyan within SSH, and a warning red if within telnet
    # else display the host without color
    # The connection is not expected to change from inside the shell, so we
    # build this just once
    LP_HOST=""

    # Only process hostname elements if we haven't turned them off
    if (( LP_HOSTNAME_ALWAYS != -1 )); then

        [[ -r /etc/debian_chroot ]] && LP_HOST="($(< /etc/debian_chroot))"

        # Which host symbol should we use?
        if (( LP_ENABLE_FQDN )); then
            LP_HOST_SYMBOL="${_LP_FQDN_SYMBOL}"
        else
            LP_HOST_SYMBOL="${_LP_HOST_SYMBOL}"
        fi

        # If we are connected with a X11 support
        if [[ -n "$DISPLAY" ]]; then
            LP_HOST="${LP_COLOR_X11_ON}${LP_HOST}@${NO_COL}"
        else
            LP_HOST="${LP_COLOR_X11_OFF}${LP_HOST}@${NO_COL}"
        fi

        local connection
        if [[ -n "${SSH_CLIENT-}${SSH2_CLIENT-}${SSH_TTY-}" ]]; then
            connection=ssh
        else
            # tmux: see GH #304
            # TODO check on *BSD
            local whoami="$(LC_ALL=C who am i)"
            local sess_parent="$(ps -o comm= -p $PPID 2> /dev/null)"
            if [[ x"$whoami" != *'('* || x"$whoami" = *'(:'* || x"$whoami" = *'(tmux'* ]]; then
                connection=lcl  # Local
            elif [[ "$sess_parent" = "su" || "$sess_parent" = "sudo" ]]; then
                connection=su   # Remote su/sudo
            else
                connection=tel  # Telnet
            fi
        fi

        case "$connection" in
        lcl)
            if (( LP_HOSTNAME_ALWAYS )); then
                LP_HOST+="${LP_COLOR_HOST}${LP_HOST_SYMBOL}${NO_COL}"
            else
                # FIXME do we want to display the chroot if local?
                LP_HOST="" # no hostname if local
            fi
            ;;
        ssh)
            # If we want a different color for each host
            (( LP_ENABLE_SSH_COLORS )) && LP_COLOR_SSH="$LP_COLOR_HOST_HASH"
            LP_HOST+="${LP_COLOR_SSH}${LP_HOST_SYMBOL}${NO_COL}"
            ;;
        su)
            LP_HOST+="${LP_COLOR_SU}${LP_HOST_SYMBOL}${NO_COL}"
            ;;
        tel)
            LP_HOST+="${LP_COLOR_TELNET}${LP_HOST_SYMBOL}${NO_COL}"
            ;;
        *)
            LP_HOST+="${LP_HOST_SYMBOL}" # defaults to no color
            ;;
        esac
    fi
}

_lp_get_home_tilde_collapsed()
{
    # Needs to be in a variable, as different versions of Bash treat '~' in a
    # substitution differently
    local tilde="~"
    lp_work_dir="${PWD/#$HOME/$tilde}"
}

# Shorten the path of the current working directory
# * Show only the current directory
# * Show as much of the cwd path as possible, if shortened display a
#   leading mark, such as ellipses, to indicate that part is missing
# * show at least LP_PATH_KEEP leading dirs and current directory
_lp_shorten_path()
{

    if (( ! LP_ENABLE_SHORTEN_PATH )); then
        # We are not supposed to come here often as this case is already
        # optimized at install time
        LP_PWD="${LP_COLOR_PATH}${LP_PATH_DEFAULT}$NO_COL"
        return
    fi

    local ret=""

    local lp_work_dir
    _lp_get_home_tilde_collapsed

    local mask="${LP_MARK_SHORTEN_PATH}"
    local -i max_len=$(( ${COLUMNS:-80} * LP_PATH_LENGTH / 100 ))

    if (( LP_PATH_KEEP == -1 )); then
        # only show the current directory, excluding any parent dirs
        ret="${lp_work_dir##*/}" # discard everything up to and including the last slash
        [[ "${ret}" == "" ]] && ret="/" # if in root directory
    elif (( ${#lp_work_dir} <= max_len )); then
        ret="$lp_work_dir"
    elif (( LP_PATH_KEEP == 0 )); then
        # len is over max len, show as much of the tail as is allowed
        ret="${lp_work_dir##*/}" # show at least complete current directory
        lp_work_dir="${lp_work_dir:0:${#lp_work_dir} - ${#ret}}"
        ret="${mask}${lp_work_dir:${#lp_work_dir} - (${max_len} - ${#ret} - ${#mask})}${ret}"
    else
        # len is over max len, show at least LP_PATH_KEEP leading dirs and
        # current directory
        local tmp="${lp_work_dir//\//}"
        local -i delims=$(( ${#lp_work_dir} - ${#tmp} ))

        for (( dir=0; dir < LP_PATH_KEEP; dir++ )); do
            (( dir == delims )) && break

            local left="${lp_work_dir#*/}"
            local name="${lp_work_dir:0:${#lp_work_dir} - ${#left}}"
            lp_work_dir="${left}"
            ret+="${name%/}/"
        done

        if (( delims <= LP_PATH_KEEP )); then
            # no dirs between LP_PATH_KEEP leading dirs and current dir
            ret+="${lp_work_dir##*/}"
        else
            local base="${lp_work_dir##*/}"

            lp_work_dir="${lp_work_dir:0:${#lp_work_dir} - ${#base}}"

            [[ ${ret} != "/" ]] && ret="${ret%/}" # strip trailing slash

            local -i len_left=$(( max_len - ${#ret} - ${#base} - ${#mask} ))

            ret+="${mask}${lp_work_dir:${#lp_work_dir} - ${len_left}}${base}"
        fi
    fi
    # Escape special chars
    _lp_escape "$ret"
    LP_PWD="${LP_COLOR_PATH}${ret}$NO_COL"
}

# In Bash shells, PROMPT_DIRTRIM is the number of directories to keep at the end
# of the displayed path (if "\w" is present in the PS1 var).
# Liquid Prompt can calculate this number under two conditions, path shortening
# must be disabled and PROMPT_DIRTRIM must be already set.
_lp_set_dirtrim() {
    local lp_work_dir
    _lp_get_home_tilde_collapsed
    local -i max_len="${COLUMNS:-80}*$LP_PATH_LENGTH/100"
    local -i dt=0

    if (( ${#lp_work_dir} > max_len )); then
        local q="/${lp_work_dir##*/}"
        local show="$q"
        # +3 because of the ellipsis: "..."
        while (( ${#show}+3 < max_len )); do
            (( dt++ ))
            lp_work_dir="${lp_work_dir%$q}"
            q="/${lp_work_dir##*/}"
            show="$q$show"
        done
        (( dt == 0 )) && dt=1
    fi
    PROMPT_DIRTRIM=$dt
    # For debugging
    # echo PROMPT_DIRTRIM=$PROMPT_DIRTRIM >&2
}



################
# Related jobs #
################

# Return the count of detached screens sessions and/or tmux sessions running
# on the host
# return: lp_detached_sessions; the number of detached sessions
_lp_detached_sessions() {
    local -i count=0
    if (( _LP_ENABLE_DETACHED_SESSIONS )); then
        (( _LP_ENABLE_SCREEN )) && count+=$(screen -ls 2> /dev/null | \grep -c '[Dd]etach[^)]*)$')
        (( _LP_ENABLE_TMUX )) && count+=$(tmux list-sessions 2> /dev/null | \grep -cv 'attached')
    fi
    lp_detached_sessions=$count
}

# Return the count of attached running jobs (started with $ myjob &) and/or
# stopped jobs (suspended with Ctrl-Z)
# return: lp_running_jobs; the number of running shell jobs
#         lp_stopped_jobs; the number of stopped shell jobs
_lp_jobcount() {
    local -i count
    # Count running jobs
    # The $(...) syntax strips trailing newlines, so add a character to the end
    # then remove it to prevent that. Otherwise 0 and 1 jobs look the same.
    jobs=$(jobs -r; printf x)
    _lp_line_count "${jobs%x}"
    lp_running_jobs=$count

    # Count stopped jobs
    jobs=$(jobs -s; printf x)
    _lp_line_count "${jobs%x}"
    lp_stopped_jobs=$count
}


######################
# VCS branch display #
######################

# Check if Git is enabled in Liquidprompt and the current directory is a valid
# Git repository. This check should be done before running any other _lp_git_*
# data functions.
# return: false if Git disabled (2) or not a valid repo (1), true otherwise.
_lp_git_active() {
    (( LP_ENABLE_GIT )) || return 2
    \git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 1
}

# Get the branch name of the Git repo in the current directory.
# return: true if a valid Git branch is checked out.
#         lp_vcs_branch; the name of the current branch.
_lp_git_branch()
{
    local branch ret
    # Recent versions of Git support the --short option for symbolic-ref, but
    # not 1.7.9 (Ubuntu 12.04)
    if branch="$(\git symbolic-ref -q HEAD)"; then
        _lp_escape "${branch#refs/heads/}"
        lp_vcs_branch="$ret"
    else
        return 1
    fi
}

# Get a tag name of the Git repo in the current directory.
# return: true if a valid Git tag matches the HEAD commit.
#         lp_vcs_tag; the name of (one of) the current tag(s).
_lp_git_tag() {
    local tag ret
    if tag="$(\git describe --tags --exact-match 2>/dev/null)"; then
        _lp_escape "$tag"
        lp_vcs_tag="$ret"
    else
        return 1
    fi
}

# Get the current commit hash of the Git repo in the current directory.
# return: lp_vcs_commit_string; the hash of the HEAD commit.
_lp_git_commit_string() {
    lp_vcs_commit_string="$(\git rev-parse HEAD 2>/dev/null)"
}

# Get additional information if HEAD is in merging, rebasing or cherry-picking
# state.
# This function depends on _lp_find_vcs() being run first to set $lp_vcs_root.
# return: true if any extra state is found.
#         lp_vcs_head_status; the extra repo state.
#         lp_vcs_head_details; optional extra details, like progress in a rebase.
_lp_git_head_status() {
    local gitdir="${lp_vcs_root}/.git" IFS=$'\r\n' step total

    if [[ -f "${gitdir}/MERGE_HEAD" ]]; then
        lp_vcs_head_status="MERGING"
    elif [[ -d "${gitdir}/rebase-merge" ]]; then
        read step <"${gitdir}/rebase-merge/msgnum"
        read total <"${gitdir}/rebase-merge/end"
        if [ -f "${gitdir}/rebase-merge/interactive" ]; then
            lp_vcs_head_status="REBASE-i"
        else
            lp_vcs_head_status="REBASE-m"
        fi
    elif [[ -d "${gitdir}/rebase-apply" ]]; then
        read step <"${gitdir}/rebase-apply/next"
        read total <"${gitdir}/rebase-apply/last"
        if [ -f "${gitdir}/rebase-apply/rebasing" ]; then
            lp_vcs_head_status="REBASE"
        elif [ -f "${gitdir}/rebase-apply/applying" ]; then
            lp_vcs_head_status="AM"
        else
            lp_vcs_head_status="AM/REBASE"
        fi
    elif [[ -f "${gitdir}/CHERRY_PICK_HEAD" ]]; then
        lp_vcs_head_status="CHERRY-PICKING"
    elif [[ -f "${gitdir}/REVERT_HEAD" ]]; then
        lp_vcs_head_status="REVERTING"
    elif [[ -f "${gitdir}/BISECT_START" ]]; then
        lp_vcs_head_status="BISECTING"
    else
        return 1
    fi

    if [[ -n "$step" && -n "$total" ]]; then
        lp_vcs_head_details="${step}/${total}"
    fi
}

# Get the number of Git stashes in the repo.
# return: true if any stashes are found.
#         lp_vcs_stash_count; the number of stashes.
_lp_git_stash_count() {
    local stashes count
    stashes="$(\git rev-parse --verify -q refs/stash; printf x)"
    _lp_line_count "${stashes%x}"
    lp_vcs_stash_count=$count
    (( lp_vcs_stash_count ))
}

# Get the number of commits ahead and behind the upstream branch.
# return: true if any commits differ from the remote branch, false if not (1)
#             or no upstream branch exists (2).
#         lp_vcs_commit_behind; the number of commits that only exist remotely.
#         lp_vcs_commit_ahead; the number of commits that only exist locally.
_lp_git_commits_off_remote() {
    local count
    # the "@{upstream}" notation was added in Git 1.7.0
    count="$(\git rev-list --count --left-right @{upstream}..HEAD 2>/dev/null)" || return 2
    IFS=$' \t' read lp_vcs_commit_behind lp_vcs_commit_ahead <<<"$count"
    (( lp_vcs_commit_behind || lp_vcs_commit_ahead ))
}

# Get the number of untracked files in the repo.
# return: true if any untracked files are found.
#         lp_vcs_untracked_files; the number of untracked files.
_lp_git_untracked_files() {
    lp_vcs_untracked_files="$(LC_ALL=C \git status --porcelain 2>/dev/null | \grep -c '^??')"
    (( lp_vcs_untracked_files ))
}

# Get the number of changed files compared to HEAD.
# return: true if any files differ from HEAD.
#         lp_vcs_uncommit_files; the number of lines changed.
_lp_git_uncommitted_files() {
    local diff
    diff="$(LC_ALL=C \git diff --shortstat HEAD -- 2>/dev/null)"

    if [[ "$diff" = *changed* ]]; then
        diff="${diff/ file*}"
        lp_vcs_uncommit_files="${diff//[$' \t']}"
    else
        return 1
    fi
}

# Get the number of changed lines compared to HEAD.
# return: true if any lines differ from HEAD.
#         lp_vcs_uncommit_i_lines; the number of lines inserted.
#         lp_vcs_uncommit_d_lines; the number of lines deleted.
_lp_git_uncommitted_lines() {
    local diff
    diff="$(LC_ALL=C \git diff --shortstat HEAD -- 2>/dev/null)"

    diff=${diff/*changed, /} # removing "n file(s) changed"

    if [[ "$diff" = *insertion* ]]; then
        lp_vcs_uncommit_i_lines="${diff/ inser*}"
    else
        lp_vcs_uncommit_i_lines=0
    fi

    if [[ "$diff" = *deletion* ]]; then
        lp_vcs_uncommit_d_lines="${diff/*\(+\), }"
        lp_vcs_uncommit_d_lines="${lp_vcs_uncommit_d_lines/ del*/}"
    else
        lp_vcs_uncommit_d_lines=0
    fi

    (( lp_vcs_uncommit_i_lines || lp_vcs_uncommit_d_lines ))
}

# Get the number of changed files compared to staging.
# return: true if any files differ from staging.
#         lp_vcs_unstaged_files; the number of files changed.
_lp_git_unstaged_files() {
    local diff
    diff="$(LC_ALL=C \git diff --shortstat 2>/dev/null)"

    if [[ "$diff" = *changed* ]]; then
        diff="${diff/ file*}"
        lp_vcs_unstaged_files="${diff//[$' \t']}"
    else
        return 1
    fi
}

# Get the number of changed lines compared to staging.
# return: true if any lines differ from staging.
#         lp_vcs_unstaged_i_lines; the number of lines inserted.
#         lp_vcs_unstaged_d_lines; the number of lines deleted.
_lp_git_unstaged_lines() {
    local stat
    stat="$(LC_ALL=C \git diff --shortstat 2>/dev/null)"

    stat=${stat/*changed, /} # removing "n file(s) changed"

    if [[ "$stat" = *insertion* ]]; then
        lp_vcs_unstaged_i_lines="${stat/ inser*}"
    else
        lp_vcs_unstaged_i_lines=0
    fi

    if [[ "$stat" = *deletion* ]]; then
        lp_vcs_unstaged_d_lines="${stat/*\(+\), }"
        lp_vcs_unstaged_d_lines="${lp_vcs_unstaged_d_lines/ del*/}"
    else
        lp_vcs_unstaged_d_lines=0
    fi

    (( lp_vcs_unstaged_i_lines || lp_vcs_unstaged_d_lines ))
}

# MERCURIAL #

# Check if Mercurial is enabled in Liquidprompt and the current directory is a
# valid Mercurial repository. Note that as 'hg' is written in Python, the
# startup cost is quite heavy, and as of this writing, 'hg root' does nothing
# more than look for a '.hg' directory, not examine the contents.
# return: false if Mercurial disabled (2) or not a valid repo (1), true
#             otherwise.
_lp_hg_active() {
    (( LP_ENABLE_HG )) || return 2
    \hg root >/dev/null 2>&1 || return 1
}

# Get the branch name of the repo in the current directory.
# return: true if a valid Mercurial branch is checked out.
#         lp_vcs_branch; the name of the current branch.
_lp_hg_branch() {
    local branch ret
    if branch="$(\hg branch 2>/dev/null)"; then
        _lp_escape "$branch"
        lp_vcs_branch="$ret"
    else
        return 1
    fi
}

# Get the most recent tag that refers to the current revision.
# return: true if a valid Mercurial tag is checked out.
#         lp_vcs_tag; the name of the current tag.
_lp_hg_tag() {
    local tag ret
    # TODO: this returns all matching tags, separated by space. But tags can
    # include a space!
    # TODO: should this use bookmarks instead?
    tag="$(\hg identify --tags 2>/dev/null)"
    if [[ -n "$tag" ]]; then
        _lp_escape "$tag"
        lp_vcs_tag="$ret"
    else
        return 1
    fi
}

# Get the current global revision id for the repo in the current directory.
# return: lp_vcs_commit_string; the global hash of the current revision.
_lp_hg_commit_string() {
    lp_vcs_commit_string="$(\hg identify --id 2>/dev/null)"
}

# Get additional information if the repo is in any unfinished state.
# This function depends on _lp_find_vcs() being run first to set $lp_vcs_root.
# return: true if any unfinished state is found.
#         lp_vcs_head_status; the extra repo state.
_lp_hg_head_status() {
    local hgdir="${lp_vcs_root}/.hg"
    if [[ -d "${hgdir}/merge" ]]; then
        lp_vcs_head_status="MERGING"
    elif [[ -f "${hgdir}/rebasestate" ]]; then
        lp_vcs_head_status="REBASING"
    elif [[ -f "${hgdir}/updatestate" ]]; then
        lp_vcs_head_status="UPDATING"
    elif [[ -f "${hgdir}/bisect.state" ]]; then
        lp_vcs_head_status="BISECTING"
    elif [[ -f "${hgdir}/shelvedstate" ]]; then
        lp_vcs_head_status="SHELVING"
    elif [[ -f "${hgdir}/graftstate" ]]; then
        lp_vcs_head_status="GRAFTING"
    else
        return 1
    fi
}

# Get the number of Mercurial shelves in the repo.
# return: true if any shelves are found.
#         lp_vcs_stash_count; the number of shelves.
_lp_hg_stash_count() {
    local shelves count
    shelves="$(\hg shelve --list 2>/dev/null; printf x)"
    _lp_line_count "${shelves%x}"
    lp_vcs_stash_count="$count"
    (( lp_vcs_stash_count ))
}

# Mercurial doesn't keep a local copy of the remote state, so checking this
# will require a connection to the remote server. This means it is often
# prohibitively time expensive, and therefore shouldn't be used in a prompt.
# https://github.com/nojhan/liquidprompt/issues/217
# return: always false (3: disabled).
_lp_hg_commits_off_remote() {
    #commits=$(\hg outgoing --no-merges 2>/dev/null | \grep -c '\(^changeset\:\)')
    return 3
}

# Get the number of untracked files in the Mercurial repo.
# return: true if any untracked files are found.
#         lp_vcs_untracked_files; the number of untracked files.
_lp_hg_untracked_files() {
    local untracked
    untracked="$(\hg status --unknown --template '{status}' 2>/dev/null)"
    lp_vcs_untracked_files="${#untracked}"
    (( lp_vcs_untracked_files ))
}

# Get the number of changed files compared to the base revision.
# return: true if any files differ from the base revision.
#         lp_vcs_uncommit_files; the number of files changed.
_lp_hg_uncommitted_files() {
    local files
    files="$(\hg status --modified --template '{status}' 2>/dev/null)"
    lp_vcs_uncommit_files="${#files}"
    (( lp_vcs_uncommit_files ))
}

# Get the number of changed lines compared to the base revision.
# return: true if any lines differ from the base revision.
#         lp_vcs_uncommit_i_lines; the number of lines inserted.
#         lp_vcs_uncommit_d_lines; the number of lines deleted.
_lp_hg_uncommitted_lines() {
    IFS=' ' read lp_vcs_uncommit_i_lines lp_vcs_uncommit_d_lines \
        <<<"$(\hg diff --stat 2>/dev/null | sed -n '$ s/^.*, \([0-9]*\) .*, \([0-9]*\).*$/\1 \2/p')"

    (( lp_vcs_uncommit_i_lines || lp_vcs_uncommit_d_lines ))
}

# Mercurial has no staging area, so this is always 0.
# return: always false (2: disabled).
_lp_hg_unstaged_files() {
    return 2
}

# Mercurial has no staging area, so this is always 0.
# return: always false (2: disabled).
_lp_hg_unstaged_lines() {
    return 2
}

# SUBVERSION #

# Check if Subversion is enabled in Liquidprompt and the current directory is a
# valid Subversion repository.
# return: false if Subversion disabled (2) or not a valid repo (1), true
#             otherwise.
_lp_svn_active() {
    (( LP_ENABLE_SVN )) || return 2
    \svn info >/dev/null 2>&1 || return 1
}

# Get the branch name of the repo in the current directory.
# return: true if a valid Subversion branch is checked out.
#         lp_vcs_branch; the name of the current branch.
_lp_svn_branch() {
    local ret url
    # SVN info shows repository-relative URLs since v1.8
    url="$(LC_ALL=C \svn info 2>/dev/null)"
    url="${url#*Relative URL: }"
    url="${url%%$'\n'*}"
    [[ -z "$url" ]] && return 1

    if [[ "$url" == */trunk* ]]; then
        lp_vcs_branch=trunk
    elif [[ "$url" == */branches/?* ]]; then
        url="${url##*/branches/}"
        _lp_escape "${url%/*}"
        lp_vcs_branch="$ret"
    elif [[ "$url" == */tags/?* ]]; then
        url="${url##*/tags/}"
        _lp_escape "${url%/*}"
        lp_vcs_branch="tag/$ret"
    else
        return 1
    fi
}

# SVN doesn't have a concept of tags, they are really branches that everyone
# agrees to not change. For this reason a "tag" is returned by the
# _lp_svn_branch() function.
# return: always false (2: disabled).
_lp_svn_tag() {
    return 2
}

# Get the current revision number for the repo in the current directory.
# return: lp_vcs_commit_string; the number of the current revision.
_lp_svn_commit_string() {
    lp_vcs_commit_string="$(\svn info --show-item revision 2>/dev/null)"
}

# Get additional information if the repo is in any unfinished state.
# A Subversion merge is no differnent than a manual file change, so the
# repository has no extra state to track.
# return: always false (2: disabled).
_lp_svn_head_status() {
    return 2
}

# Subversion _still_ does not have stash functionality
# return: always false (2: disabled)
_lp_svn_stash_count() {
    return 2
}

# Subversion is not distributed, so it is always in sync with the remote.
# return: always false (3: disabled).
_lp_svn_commits_off_remote() {
    return 3
}

# Get the number of untracked files in the Subversion repo.
# return: true if any untracked files are found.
#         lp_vcs_untracked_files; the number of untracked files.
_lp_svn_untracked_files() {
    lp_vcs_untracked_files="$(LC_ALL=C \svn status 2>/dev/null | \grep -c '^?')"
    (( lp_vcs_untracked_files ))
}

# Get the number of changed files compared to the base revision.
# return: true if any files differ from the base revision.
#         lp_vcs_uncommit_files; the number of files changed.
_lp_svn_uncommitted_files() {
    local files count
    # svn status is unsafe with newline chars in filenames, which will throw
    # off this count
    files="$(\svn status --quiet 2>/dev/null; printf x)"
    _lp_line_count "${files%x}"
    lp_vcs_uncommit_files="$count"
    (( lp_vcs_uncommit_files ))
}

# Get the number of changed lines compared to the base revision.
# return: true if any lines differ from the base revision.
#         lp_vcs_uncommit_i_lines; the number of lines inserted.
#         lp_vcs_uncommit_d_lines; the number of lines deleted.
_lp_svn_uncommitted_lines() {
    IFS=' ' read lp_vcs_uncommit_i_lines lp_vcs_uncommit_d_lines \
        <<<"$(\svn diff --internal-diff 2>/dev/null | awk '
        BEGIN { plus=0; minus=0 }
        /^(\+[^+])|(\+$)/ { plus+=1 }
        /^(-[^-])|(-$)/ { minus+=1 }
        END {
            print plus" "minus
        }')"

    (( lp_vcs_uncommit_i_lines || lp_vcs_uncommit_d_lines ))
}

# Subversion has no staging area, so this is always 0.
# return: always false (2: disabled).
_lp_svn_unstaged_files() {
    return 2
}

# Subversion has no staging area, so this is always 0.
# return: always false (2: disabled).
_lp_svn_unstaged_lines() {
    return 2
}

# FOSSIL #

# Check if Fossil is enabled in Liquidprompt and the current directory is a
# valid Fossil repository. This check should be done before running any other
# _lp_fossil_* data functions.
# return: false if Fossil disabled (2) or not a valid repo (1), true otherwise.
_lp_fossil_active() {
    (( LP_ENABLE_FOSSIL )) || return 2
    \fossil status >/dev/null 2>&1 || return 1
}

# Get the branch name of the repo in the current directory.
# return: true if a valid Fossil branch is checked out.
#         lp_vcs_branch; the name of the current branch.
_lp_fossil_branch() {
    local branch ret

    # branch current command added in fossil 2.7
    if ! branch="$(\fossil branch current 2>/dev/null)"; then
        # Almost any character can be in a branch name, but we have no way of
        # knowing if a newline is part of the name or not. In fact, there is no
        # way to prevent a branch containing the string '\n* ' to not break
        # this. Just hope that no one crazy enough to do that to their branch
        # names is running Fossil <2.7
        branch="$(\fossil branch list 2>/dev/null)"
        branch="${branch#*$'\n\* '}"
        # If the current branch is the first in the list, the above check would
        # not have removed anything
        branch="${branch#\* }"
        branch="${branch%%$'\n'*}"
    fi

    if [[ -n "$branch" ]]; then
        _lp_escape "$branch"
        lp_vcs_branch="$ret"
    else
        return 1
    fi
}

# A Fossil tag can refer to multiple checkin IDs, so a matching tag is not a
# useful ID for where we are.
# return: always false (2: disabled).
_lp_fossil_tag() {
    return 2
}

# Get the current commit hash of the Fossil repo in the current directory.
# return: lp_vcs_commit_string; the hash of the current check-out.
_lp_fossil_commit_string() {
    lp_vcs_commit_string="$(\fossil status 2>/dev/null | sed -n 's/^checkout:[[:space:]]*\([^[:space:]]*\).*/\1/p')"
}

# Get additional information if the check-out is in merging before a commit.
# Like Git, Fossil has a way to abort or undo in progress changes before a
# commit is actually written.
# return: true if any extra state is found.
#         lp_vcs_head_status; the extra repo state.
_lp_fossil_head_status() {
    local option
    option="$(\fossil undo --dry-run 2>/dev/null)"

    if [[ "$option" == *"fossil merge"* ]]; then
        lp_vcs_head_status="MERGING"
    else
        return 1
    fi
}

# Get the number of Fossil stashes in the repo.
# return: true if any stashes are found.
#         lp_vcs_stash_count; the number of stashes.
_lp_fossil_stash_count() {
    local stashes count
    stashes="$(\fossil stash list 2>/dev/null; printf x)"
    _lp_line_count "${stashes%x}"
    # Each stash takes up two lines, and no stashes is one line
    lp_vcs_stash_count=$(( count / 2 ))
    (( lp_vcs_stash_count ))
}

# Fossil by default keeps the local repo in sync with the remote. Even if a
# user disables that, it is not possible to have a local and remote branch
# named the same not in sync.
# return: always false (3: disabled).
_lp_fossil_commits_off_remote() {
    return 3
}

# Get the number of extra files in the Fossil repo.
# return: true if any untracked files are found.
#         lp_vcs_untracked_count; the number of untracked files.
_lp_fossil_untracked_files() {
    local extras count
    extras="$(\fossil extras 2>/dev/null; printf x)"
    _lp_line_count "${extras%x}"
    lp_vcs_untracked_files="$count"
    (( lp_vcs_untracked_files ))
}

# Get the number of changed files compared to the checked-out version.
# return: true if any files differ from check-out.
#         lp_vcs_uncommit_files; the number of files changed.
_lp_fossil_uncommitted_files() {
    local files
    files="$(\fossil changes 2>/dev/null; printf x)"
    _lp_line_count "${files%x}"
    lp_vcs_uncommit_files="$count"
    (( lp_vcs_uncommit_files ))
}

# Get the number of changed lines compared to the checked-out version.
# return: true if any lines differ from check-out.
#         lp_vcs_uncommit_i_lines; the number of lines inserted.
#         lp_vcs_uncommit_d_lines; the number of lines deleted.
_lp_fossil_uncommitted_lines() {
    IFS=' ' read lp_vcs_uncommit_i_lines lp_vcs_uncommit_d_lines \
        <<<"$(\fossil diff --internal --verbose 2>/dev/null | awk '
        BEGIN { plus=0; minus=0 }
        /^(\+[^+])|(\+$)/ { plus+=1 }
        /^(-[^-])|(-$)/ { minus+=1 }
        END {
            print plus" "minus
        }')"

    (( lp_vcs_uncommit_i_lines || lp_vcs_uncommit_d_lines ))
}

# Fossil has no staging area, so this is always 0.
# return: always false (2: disabled).
_lp_fossil_unstaged_files() {
    return 2
}

# Fossil has no staging area, so this is always 0.
# return: always false (2: disabled).
_lp_fossil_unstaged_lines() {
    return 2
}

# Bazaar #

# Get the branch name of the current directory
_lp_bzr_branch()
{
    (( LP_ENABLE_BZR )) || return 2

    # We found an .bzr folder, so we need to invoke bzr and see if we're
    # actually in a repository.

    local branch ret
    if branch="$(bzr nick 2> /dev/null)"; then
        _lp_escape "$branch"
        lp_vcs_branch="$ret"
    else
        return 1
    fi
}


# Set a color depending on the branch state:
# - green if the repository is up to date
# - red if there is changes to commit
# - TODO: yellow if there is some commits not pushed
#
# Add the number of pending commits and the impacted lines.
_lp_bzr_branch_color()
{
    (( LP_ENABLE_BZR )) || return 2

    # We found an .bzr folder, so we need to invoke bzr and see if we're
    # actually in a repository.

    local branch revno clean IFS=' '
    if read -r branch revno clean <<<"$(bzr version-info --check-clean --custom \
        --template='{branch_nick} {revno} {clean}' 2>/dev/null)" && [[ -n "$branch" ]]; then

        _lp_escape "$branch"
        if (( clean == 0 )); then
            lp_vcs_branch_color="${LP_COLOR_CHANGES}${ret}${NO_COL}(${LP_COLOR_COMMITS}$revno${NO_COL})"
        else
            lp_vcs_branch_color="${LP_COLOR_UP}${ret}${NO_COL}(${LP_COLOR_COMMITS}$revno${NO_COL})"
        fi
    else
        return 1
    fi
}

# Search upwards through a directory structure looking for a sign of a VCS
# repository. Used to avoid invoking VCS binaries to discover if in a repo.
# Checks $LP_DISABLED_VCS_PATH and returns false if a match is found.
# Otherwise returns the first matching repository.
# return: true if in repo, false if not (1) or path disabled (2).
#         lp_vcs_type; the string ID of the VCS controlling this directory.
#         lp_vcs_root; the path to the root of the found repository.
_lp_find_vcs() {
    local path
    for path in "${LP_DISABLED_VCS_PATH[@]}"; do
        if [[ -n "$path" && "$PWD" == "$path"* ]]; then
            lp_vcs_type="disabled"
            lp_vcs_root=""
            return 2
        fi
    done

    local dir
    dir="$PWD"
    while [[ -n "$dir" ]]; do
        lp_vcs_root="$dir"
        for vcs in "${LP_ENABLED_VCSS[@]}"; do
            if [[ -d "$dir/.$vcs" ]]; then
                lp_vcs_type="$vcs"
                return 0
            elif (( LP_ENABLE_FOSSIL)) && [[ -f "$dir/_FOSSIL_" || -f "$dir/.fslckout" ]]; then
                lp_vcs_type="fossil"
                return 0
            fi
        done
        dir="${dir%/*}"
    done

    lp_vcs_type=""
    lp_vcs_root=""
    return 1
}

# Check if the detected VCS is enabled in Liquidprompt and the current
# directory is a valid repository of that type. This check should be done
# before running any other _lp_vcs_* data functions, but can be omitted for
# speed reasons if the checks done by _lp_find_vcs() are good enough.
# return: false if VCS disabled (2) or not a valid repo (1), true otherwise.
_lp_vcs_active() {
    _lp_${lp_vcs_type}_active 2>/dev/null
}

# Get the branch name of the repo in the current directory. Note that not all
# VCS providers will always have a current branch; some like Git can leave the
# repo in a "detached HEAD" state.
# return: true if a valid VCS branch is checked out.
#         lp_vcs_branch; the name of the current branch.
_lp_vcs_branch() {
    _lp_${lp_vcs_type}_branch 2>/dev/null
}

# Get a tag name of the repo in the current directory. Note that not all VCS
# providers support tags that match to one and only one commit object.
# return: true if a valid VCS tag matches the HEAD commit. False if no tag
#             matches (1) or unique tags are not supported (2+).
#         lp_vcs_tag; the name of (one of) the current tag(s).
_lp_vcs_tag() {
    _lp_${lp_vcs_type}_tag 2>/dev/null
}

# Get the current short commit string for the repo in the current directory.
# Some VCS providers identify commits by a hash, others use a revision number.
# The returned string should be unique enough that a user can identify the
# commit. This should never fail if the current directory is a valid repo.
# Note that some VCS providers will return a very long string, and it might be
# a good idea to truncate this string to 7 chars or so.
# return: lp_vcs_commit_string; a short string that can ID the current commit.
_lp_vcs_commit_string() {
    _lp_${lp_vcs_type}_commit_string 2>/dev/null
}

# Get additional information if the repo is in a special or unusual state.
# Many VCS providers don't have such information, and many users either don't
# care to see it or rarely get in a repo state that has any such info. This
# info is unlikely to be similar across VCSs, and should probably be displayed
# to a user without manipulation.
# return: true if any extra state is found, false if not (1) or the VCS
#             provider does not support any useful extra info (2+).
#         lp_vcs_head_status; the extra repo state
#         lp_vcs_head_details; optional extra details.
_lp_vcs_head_status() {
    lp_vcs_head_details=
    _lp_${lp_vcs_type}_head_status 2>/dev/null
}

# Get the number of stashes in the repo. Not all VCS providers support stashes.
# return: true if any stashes are found, false if not (1) or the VCS does not
#             support stashes (2+).
#         lp_vcs_stash_count; the number of stashes
_lp_vcs_stash_count() {
    _lp_${lp_vcs_type}_stash_count 2>/dev/null
}

# Get the number of commits ahead and behind the upstream branch. Many VCS
# providers cannot provide these numbers, simply because they simply don't work
# that way.
# return: true if any commits differ from the remote branch, false if not (1),
#             no upstream branch exists (2), or not supported by the VCS (3+).
#         lp_vcs_commit_behind; the number of commits that only exist remotely.
#         lp_vcs_commit_ahead; the number of commits that only exist locally.
_lp_vcs_commits_off_remote() {
    _lp_${lp_vcs_type}_commits_off_remote 2>/dev/null
}

# Get the number of untracked aka extra files in the repo. This count excludes
# files explicitly ignored by the user.
# return: true if any untracked files are found.
#         lp_vcs_untracked_files; the number of untracked files.
_lp_vcs_untracked_files() {
    _lp_${lp_vcs_type}_untracked_files 2>/dev/null
}

# Get the number of changed files compared to the last or checked out commit.
# return: true if any files differ from the latest commit.
#         lp_vcs_uncommit_files; the number of lines changed.
_lp_vcs_uncommitted_files() {
    _lp_${lp_vcs_type}_uncommitted_files 2>/dev/null
}

# Get the number of changed lines compared to the last or checked out commit.
# return: true if any lines differ from the latest commit.
#         lp_vcs_uncommit_i_lines; the number of lines inserted.
#         lp_vcs_uncommit_d_lines; the number of lines deleted.
_lp_vcs_uncommitted_lines() {
    _lp_${lp_vcs_type}_uncommitted_lines 2>/dev/null
}

# Get the number of changed files compared to staging. Many VCS providers do
# not have a staging area, and one might need to fall back to
# uncommitted_files() instead.
# return: true if any files differ from staging, false if not (1), or the VCS
#             does not support staging (2).
#         lp_vcs_unstaged_files; the number of files changed.
_lp_vcs_unstaged_files() {
    _lp_${lp_vcs_type}_unstaged_files 2>/dev/null
}

# Get the number of changed lines compared to staging. Many VCS providers do
# not have a staging area, and one might need to fall back to
# uncommitted_lines() instead.
# return: true if any lines differ from staging, false if not (1), or the VCS
#             does not support staging (2).
#         lp_vcs_unstaged_i_lines; the number of lines inserted.
#         lp_vcs_unstaged_d_lines; the number of lines deleted.
_lp_vcs_unstaged_lines() {
    _lp_${lp_vcs_type}_unstaged_lines 2>/dev/null
}


####################
# Wifi link status #
####################
# TODO: test/fix/implement this
_lp_wifi()
{
    # Linux
    sed -n '3s/^ *[^ ]*  *[^ ]*  *\([0-9]*\).*/\1/p' /proc/net/wireless
}

##################
# Battery status #
##################

# Get the battery status in percent
# returns 0 (and battery level) if battery is discharging and under threshold
# returns 1 (and battery level) if battery is discharging and above threshold
# returns 2 (and battery level) if battery is charging but under threshold
# returns 3 (and battery level) if battery is charging and above threshold
# returns 4 if no battery support
case "$LP_OS" in
    Linux)
    _lp_battery()
    {
        (( LP_ENABLE_BATT )) || return 4
        local acpi
        acpi="$(acpi --battery 2>/dev/null)"
        # Extract the battery load value in percent
        # First, remove the beginning of the line...
        local bat="${acpi#Battery *, }"
        bat="${bat%%%*}" # remove everything starting at '%'

        if [[ -z "${bat}" ]]; then
            # no battery level found
            return 4
        fi
        lp_battery_level="$bat"
        # discharging
        if [[ "$acpi" == *"Discharging"* ]]; then
            # under => 0, above => 1
            return $(( bat > LP_BATTERY_THRESHOLD ))
        # not charging
        elif [[ "$acpi" == *"Not charging"* ]]; then
            return 4
        # charging
        else
            # under => 2, above => 3
            return $(( 2 + ( bat > LP_BATTERY_THRESHOLD ) ))
        fi
    }
    ;;
    Darwin)
    _lp_battery()
    {
        (( LP_ENABLE_BATT )) || return 4
        local percent batt_status
        eval "$(pmset -g batt | sed -n 's/^ -InternalBattery.*[[:space:]]\([0-9]*[0-9]\)%; \([^;]*\).*$/percent=\1 batt_status='\'\\2\'/p)"
        case "$batt_status" in
            charged | "")
            return 4
            ;;
            discharging)
                lp_battery_level="$percent"
                # under => 0, above => 1
                return $(( percent > LP_BATTERY_THRESHOLD ))
            ;;
            *)  # "charging", "AC attached"
                lp_battery_level="$percent"
                # under => 2, above => 3
                return $(( 2 + ( percent > LP_BATTERY_THRESHOLD ) ))
            ;;
        esac
    }
    ;;
esac

# Compute a gradient of background/foreground colors depending on the battery status
# Display:
# a  green ⏚ if the battery is charging    and above threshold
# a yellow ⏚ if the battery is charging    and under threshold
# a yellow ⌁ if the battery is discharging but above threshold
# a    red ⌁ if the battery is discharging and above threshold
_lp_battery_color()
{
    local mark=$LP_MARK_BATTERY
    local chargingmark=$LP_MARK_ADAPTER
    _lp_battery
    local -i ret=$?

    if (( ret == 4 || lp_battery_level == 100 )); then
        # no battery support or battery full: nothing displayed
        lp_batt_color=""
        return 1
    elif (( ret == 3 && lp_battery_level != 100 )); then
        # charging and above threshold and not 100%
        # green ⏚
        lp_batt_color="${LP_COLOR_CHARGING_ABOVE}$chargingmark${NO_COL}"
    elif (( ret == 2 )); then
        # charging but under threshold
        # yellow ⏚
        lp_batt_color="${LP_COLOR_CHARGING_UNDER}$chargingmark${NO_COL}"
    elif (( ret == 1 )); then
        # discharging but above threshold
        # yellow ⌁
        lp_batt_color="${LP_COLOR_DISCHARGING_ABOVE}$mark${NO_COL}"
    # discharging and under threshold
    else
        lp_batt_color="${LP_COLOR_DISCHARGING_UNDER}${mark}${NO_COL}"

        if (( LP_PERCENTS_ALWAYS )); then
            local ret
            # Invert, as higher battery is better
            _lp_color_map $(( 100 - lp_battery_level ))
            lp_batt_color+="${ret}${lp_battery_level}$_LP_PERCENT${NO_COL}"
        fi # LP_PERCENTS_ALWAYS
    fi
}

_lp_color_map() {
    # Default scale: 0..100
    # Custom scale: 0..$2
    local -i scale value
    scale=${2:-100}
    if (( $1 >= scale )); then
      value=scale-1
    elif (( $1 < 0 )); then
      value=0
    else
      value=$1
    fi
    # Transform the value to a 0..${#COLOR_MAP} scale
    ret="${LP_COLORMAP[_LP_FIRST_INDEX+value*${#LP_COLORMAP[*]}/scale]}"
}

###########################
# runtime of last command #
###########################

_lp_runtime_format()
{
    lp_runtime_format=
    if (( LP_ENABLE_RUNTIME && _LP_RUNTIME_SECONDS >= LP_RUNTIME_THRESHOLD )); then
        # display runtime seconds as days, hours, minutes, and seconds
        (( _LP_RUNTIME_SECONDS >= 86400 )) && lp_runtime_format+="$((_LP_RUNTIME_SECONDS / 86400))d"
        (( _LP_RUNTIME_SECONDS >= 3600 )) && lp_runtime_format+="$((_LP_RUNTIME_SECONDS % 86400 / 3600))h"
        (( _LP_RUNTIME_SECONDS >= 60 )) && lp_runtime_format+="$((_LP_RUNTIME_SECONDS % 3600 / 60))m"
        lp_runtime_format+="$((_LP_RUNTIME_SECONDS % 60))s"
    else
        return 1
    fi
}

if $_LP_SHELL_zsh; then
    _lp_runtime_before() {
      _LP_RUNTIME_LAST_SECONDS=$SECONDS
    }
    _lp_runtime_after() {
        if [[ -n "$_LP_RUNTIME_LAST_SECONDS" ]]; then
            (( _LP_RUNTIME_SECONDS=SECONDS-_LP_RUNTIME_LAST_SECONDS ))
            unset _LP_RUNTIME_LAST_SECONDS
        fi
    }
else
    _lp_runtime_before()
    {
        # For debugging
        #echo "XXX $BASH_COMMAND"

        # If this is the first time after the user submitted the command,
        # record the time
        if (( _LP_AT_PROMPT )); then
            _LP_RUNTIME_SECONDS=-1 _LP_RUNTIME_LAST_SECONDS=$SECONDS _LP_AT_PROMPT=0
        fi
        # If this is when the prompt is being drawn, the command is done,
        # so calculate the time. Note these two events could be at the same
        # time, so no elif is used
        if [[ "$BASH_COMMAND" == "$PROMPT_COMMAND" ]]; then
            _LP_AT_PROMPT=1
            # Compute number of seconds since program was started
            if [[ -n "${_LP_RUNTIME_LAST_SECONDS-}" ]] ; then
                (( _LP_RUNTIME_SECONDS=SECONDS-_LP_RUNTIME_LAST_SECONDS ))
                unset _LP_RUNTIME_LAST_SECONDS
            fi
        fi
    }
fi

###############
# System load #
###############

# Compute a gradient of background/forground colors depending on the battery status
_lp_load_color()
{
    # Colour progression is important ...
    #   bold gray -> bold green -> bold yellow -> bold red ->
    #   black on red -> bold white on red
    #
    # Then we have to choose the values at which the colours switch, with
    # anything past yellow being pretty important.

    local lp_cpu_load
    # Get value (OS-specific) into lp_cpu_load
    _lp_cpu_load

    lp_cpu_load=${lp_cpu_load/./}   # Remove '.'
    lp_cpu_load=${lp_cpu_load#0}    # Remove leading '0'
    lp_cpu_load=${lp_cpu_load#0}    # Remove leading '0', again (ex: 0.09)
    local -i load=${lp_cpu_load:-0}/$_lp_CPUNUM

    if (( load > LP_LOAD_THRESHOLD )); then
        local ret
        _lp_color_map $load
        lp_load_color="${ret}${LP_MARK_LOAD}"

        if (( LP_PERCENTS_ALWAYS )); then
            lp_load_color+="${load}${_LP_PERCENT}"
        fi
        lp_load_color+="${NO_COL}"
    else
        lp_load_color=
        return 1
    fi
}

######################
# System temperature #
######################

# Will set _LP_TEMP_FUNCTION so the temperature monitoring feature use an
# available command.
# Backends for TEMP. Each backend must return the result in $temperature.

# Implementation using lm-sensors
_lp_temp_sensors()
{
    # Return the hottest system temperature we get through the sensors command
    # Only the integer part is retained
    local -i i
    local IFS=$' \t\n'
    for i in $(sensors -u |
            sed -n 's/^  temp[0-9][0-9]*_input: \([0-9]*\)\..*$/\1/p'); do
        (( i > ${temperature:-0} )) && temperature=i
    done
}

# Implementation using 'acpi -t'
_lp_temp_acpi()
{
    local -i i
    local IFS=$' \t\n'
    # Only the integer part is retained
    for i in $(LC_ALL=C acpi -t |
            sed 's/.* \(-\?[0-9]*\)\.[0-9]* degrees C$/\1/p'); do
        (( i > ${temperature:-0} )) && temperature=i
    done
}

# Dynamic selection of backend
_lp_temp_detect()
{
    local -i temperature
    local cmd

    # Global variable
    unset _LP_TEMP_FUNCTION

    for cmd
    do
        command -v $cmd >/dev/null || continue

        _LP_TEMP_FUNCTION=_lp_temp_$cmd
        # Check that we can retrieve temperature at least once
        $_LP_TEMP_FUNCTION 2>/dev/null
        # If $temperature is set, success!
        [[ -n "$temperature" ]] && return 0
        unset _LP_TEMP_FUNCTION
    done
    return 1
}


##########
# DESIGN #
##########

# Remove all colors and escape characters of the given string and return a pure text
_lp_as_text()
{
    # Remove all terminal sequences that we wrapped with $_LP_OPEN_ESC and
    # $_LP_CLOSE_ESC.
    echo -nE "$1" | sed -$_LP_SED_EXTENDED "s,$_LP_CLEAN_ESC,,g"
}

_lp_title()
{
    (( LP_ENABLE_TITLE )) || return

    # Get the current computed prompt as pure text
    echo -nE "${_LP_OPEN_ESC}${LP_TITLE_OPEN}"
    _lp_as_text "$1"
    echo -nE "${LP_TITLE_CLOSE}${_LP_CLOSE_ESC}"
}

# Set the prompt mark to ± if git, to ☿ if mercurial, to ‡ if subversion
# to # if root and else $
_lp_smart_mark()
{
    case "${1:-$lp_vcs_type}" in
    git)
        lp_smart_mark="$LP_MARK_GIT"

        if [[ -n "${VCSH_DIRECTORY-}" ]]; then
            lp_smart_mark="$LP_MARK_VCSH$LP_MARK_GIT$LP_MARK_VCSH"
        elif [[ -d "${lp_vcs_root}/.git/svn" ]]; then
            lp_smart_mark="$LP_MARK_GIT$LP_MARK_SVN"
        fi
        ;;
    hg)       lp_smart_mark="$LP_MARK_HG"              ;;
    svn)      lp_smart_mark="$LP_MARK_SVN"             ;;
    fossil)   lp_smart_mark="$LP_MARK_FOSSIL"          ;;
    bzr)      lp_smart_mark="$LP_MARK_BZR"             ;;
    disabled) lp_smart_mark="$LP_MARK_DISABLED"        ;;
    *)        lp_smart_mark="$LP_MARK_DEFAULT"         ;;
    esac
}


###################
# CURRENT TIME    #
###################

# LP_TIME is set colored, with a space on the right side
if (( LP_ENABLE_TIME )); then
    if (( LP_TIME_ANALOG )); then
        typeset -i _LP_CLOCK_PREV=-1
        # The targeted unicode characters are the "CLOCK FACE" ones
        # They are located in the codepages between:
        #     U+1F550 (ONE OCLOCK) and U+1F55B (TWELVE OCLOCK), for the plain hours
        #     U+1F55C (ONE-THIRTY) and U+1F567 (TWELVE-THIRTY), for the thirties
        # Generated with:
        # perl -C -E 'say join("", map {chr(0x1F550+$_)." ".chr(0x1F55C+$_)." "} 0..11)'
        _LP_CLOCK=(🕐 🕜 🕑 🕝 🕒 🕞 🕓 🕟 🕔 🕠 🕕 🕡 🕖 🕢 🕗 🕣 🕘 🕤 🕙 🕥 🕚 🕦 🕛 🕧 )

        _lp_time()
        {
            # %I: "00".."12"  %M: "00".."59"
            # Bash interprets a '0' prefix as octal
            # so we have to clean that
            local hhmm="$(date "+hh=%I mm=%M")" IFS=' '
            # hh:  1..12  mm: 0..59
            local -i hh mm clock
            eval ${hhmm//=0/=}  # Line split for zsh
            # clock: 0 .. 25
            #   1:00..1:14 -> 0
            #   1:15..1:44 -> 1
            #   1:45..2:15 -> 2
            #   ...
            #   12:15..12:44 -> 23
            #   12:45..12:59 -> 0
            if (( ( clock=((hh*60+mm-45)/30)%24 ) != _LP_CLOCK_PREV )); then
                # There is a space just after the clock char because the glyph
                # width is twice usual glyphs
                lp_time="${LP_COLOR_TIME}${_LP_CLOCK[clock+_LP_FIRST_INDEX]} ${NO_COL}"
                _LP_CLOCK_PREV=clock
            fi
        }
    else
        # Never changes
        lp_time="${LP_COLOR_TIME}${_LP_TIME_SYMBOL}${NO_COL}"
        _lp_time() { : ; }
    fi
else
    lp_time=""
    _lp_time() { : ; }
fi

# Theme

# Display the count of each if non-zero:
# - detached screens sessions and/or tmux sessions running on the host
# - attached running jobs (started with $ myjob &)
# - attached stopped jobs (suspended with Ctrl-Z)
# return: lp_jobs; formatted string showing background shell jobs
_lp_jobcount_color() {
    lp_jobs_color=""

    _lp_detached_sessions
    (( lp_detached_sessions > 0 )) && lp_jobs_color+="${LP_COLOR_JOB_D}${lp_detached_sessions}d${NO_COL}"

    _lp_jobcount
    if (( lp_running_jobs > 0 )); then
        [[ -n "$lp_jobs_color" ]] && lp_jobs_color+='/'
        lp_jobs_color+="${LP_COLOR_JOB_R}${lp_running_jobs}&${NO_COL}"
    fi
    if (( lp_stopped_jobs > 0 )); then
        [[ -n "$lp_jobs_color" ]] && lp_jobs_color+='/'
        lp_jobs_color+="${LP_COLOR_JOB_Z}${lp_stopped_jobs}z${NO_COL}"
    fi
}

# Will display the numeric value as we get through the _LP_TEMP_FUNCTION
# and colorize it through _lp_color_map.
_lp_temp_color() {
    local -i lp_temperature
    lp_temperature=0
    $_LP_TEMP_FUNCTION

    if (( temperature >= LP_TEMP_THRESHOLD )); then
        local ret
        _lp_color_map $temperature 120
        lp_temp_color="${LP_MARK_TEMP}${ret}$temperature°${NO_COL}"
    else
        return 1
    fi
}

_lp_runtime_color() {
    local lp_runtime_format
    _lp_runtime_format || return $?
    lp_runtime_color="${LP_COLOR_RUNTIME}${lp_runtime_format}${NO_COL}"
}

# Set a color depending on the branch state:
# - green if the repository is up to date
# - yellow if there is some commits not pushed
# - red if there is changes to commit
# Add the number of pending commits and the impacted lines.
# return: lp_vcs_branch_color; the detailed formatted string of repo details
_lp_vcs_details_color()
{
    local branch
    if _lp_vcs_branch; then
        branch="$lp_vcs_branch"
    elif _lp_vcs_tag; then
        branch="tag: $lp_vcs_tag"
    else
        _lp_vcs_commit_string
        branch="${lp_vcs_commit_string:0:7}"
    fi

    lp_vcs_branch_color="$LP_COLOR_UP"

    local has_commit=
    if _lp_vcs_commits_off_remote; then
        lp_vcs_branch_color="$LP_COLOR_COMMITS_BEHIND"
        if [[ "$lp_vcs_commit_ahead" -ne "0" && "$lp_vcs_commit_behind" -ne "0" ]]; then
            has_commit="${LP_COLOR_COMMITS}+$lp_vcs_commit_ahead${NO_COL}/${LP_COLOR_COMMITS_BEHIND}-$lp_vcs_commit_behind${NO_COL}"
        elif [[ "$lp_vcs_commit_ahead" -ne "0" ]]; then
            has_commit="${LP_COLOR_COMMITS}$lp_vcs_commit_ahead${NO_COL}"
            lp_vcs_branch_color="$LP_COLOR_COMMITS"
        elif [[ "$lp_vcs_commit_behind" -ne "0" ]]; then
            has_commit="${LP_COLOR_COMMITS_BEHIND}-$lp_vcs_commit_behind${NO_COL}"
        fi
    fi

    local ret has_lines=
    if _lp_vcs_uncommitted_lines; then
        _lp_vcs_unstaged_lines; ret=$?
        # Only show unstaged changes if the VCS supports staging, otherwise
        # show uncommited changes
        if (( ret == 0 )); then
            has_lines="+$lp_vcs_unstaged_i_lines/-$lp_vcs_unstaged_d_lines"
        elif (( ret == 1 )); then
            has_lines="+0/-0"
        else
            has_lines="+$lp_vcs_uncommit_i_lines/-$lp_vcs_uncommit_d_lines"
        fi
        lp_vcs_branch_color="$LP_COLOR_CHANGES"
    fi

    lp_vcs_branch_color+="$branch"
    if [[ -n "$has_lines" || -n "$has_commit" ]]; then
        lp_vcs_branch_color+="${NO_COL}("
        if [[ -n "$has_lines" ]]; then
            lp_vcs_branch_color+="${LP_COLOR_DIFF}${has_lines}${NO_COL}${has_commit:+,}"
        fi
        lp_vcs_branch_color+="${has_commit})"
    fi

    # Show if there are any stashes
    if _lp_vcs_stash_count; then
        lp_vcs_branch_color+="$LP_COLOR_COMMITS$LP_MARK_STASH"
    fi

    # Show if there are any untracked files
    if _lp_vcs_untracked_files; then
        lp_vcs_branch_color+="$LP_COLOR_CHANGES$LP_MARK_UNTRACKED"
    fi

    if _lp_vcs_head_status; then
        lp_vcs_branch_color+="$LP_COLOR_CHANGES$lp_vcs_head_status"
        if [[ -n "$lp_vcs_head_details" ]]; then
            lp_vcs_branch_color+=" $lp_vcs_head_details"
        fi
    fi

    lp_vcs_branch_color+="$NO_COL"
}

########################
# Construct the prompt #
########################

lp_theme_prompt() {

    PS1="${LP_PS1_PREFIX}"

    # left of main prompt: space at right
    if (( LP_ENABLE_TIME )); then
        _lp_time
        [[ -n $lp_time ]] && PS1+="$lp_time "
    fi
    if (( LP_ENABLE_BATT )); then
        _lp_battery_color && PS1+="$lp_batt_color "
    fi
    if (( LP_ENABLE_LOAD )); then
        _lp_load_color && PS1+="$lp_load_color "
    fi
    if (( LP_ENABLE_TEMP )); then
        _lp_temp_color && PS1+="$lp_temp_color "
    fi
    if (( LP_ENABLE_JOBS )); then
        _lp_jobcount_color
        [[ -n $lp_jobs_color ]] && PS1+="$lp_jobs_color "
    fi

    # add user, host and permissions colon
    PS1+="${LP_BRACKET_OPEN}${LP_USER}${LP_HOST}${LP_PERM}${LP_PWD}${LP_BRACKET_CLOSE}"

    # Display the current software collections enabled, if available
    if [[ "$LP_ENABLE_SCLS,${X_SCLS-}" = 1,?* ]]; then
        PS1+=" [${LP_COLOR_VIRTUALENV}${X_SCLS%"${X_SCLS##*[![:space:]]}"}${NO_COL}]"
    fi

    # Display the current Python virtual environment, if available
    if [[ "$LP_ENABLE_VIRTUALENV,${VIRTUAL_ENV-}${CONDA_DEFAULT_ENV-}" = 1,?* ]]; then
        if [[ -n "${VIRTUAL_ENV-}" ]]; then
            PS1+=" [${LP_COLOR_VIRTUALENV}${VIRTUAL_ENV##*/}${NO_COL}]"
        else
            PS1+=" [${LP_COLOR_VIRTUALENV}${CONDA_DEFAULT_ENV##*/}${NO_COL}]"
        fi
    fi

    # in main prompt: no space
    if [[ "$LP_ENABLE_PROXY,${http_proxy-}" = 1,?* ]]; then
        PS1+="$LP_COLOR_PROXY$LP_MARK_PROXY$NO_COL"
    fi

    # Add VCS infos
    # If root, the info has not been collected unless LP_ENABLE_VCS_ROOT
    # is set.
    if _lp_find_vcs; then
        _lp_vcs_details_color && PS1+=" $lp_vcs_branch_color"
    fi


    if (( LP_ENABLE_RUNTIME )); then
        _lp_runtime_color && PS1+=" $lp_runtime_color"
    fi

    # Display the return value of the last command, if different from zero
    if (( lp_err != 0 )); then
        PS1+=" $LP_COLOR_ERR$lp_err$NO_COL"
    fi

    _lp_sudo_check

    # add prompt mark
    # end of the prompt line: double spaces
    _lp_smart_mark
    PS1+="${LP_MARK_PREFIX}${LP_COLOR_MARK}${lp_smart_mark}${NO_COL} ${LP_PS1_POSTFIX}"

    # "invisible" parts
    # Get the current prompt on the fly and make it a title
    PS1="$(_lp_title "$PS1")$PS1"

    # Glue the bash prompt always go to the first column.
    # Avoid glitches after interrupting a command with Ctrl-C
    # Does not seem to be necessary anymore?
    #PS1="\[\033[G\]${PS1}${NO_COL}"
}

_lp_set_prompt()
{
    # As this get the last returned code, it should be called first
    local -i lp_err=$?

    #TODO: unused?
    local GREP_OPTIONS=

    # bash: execute the old prompt hook
    eval "$LP_OLD_PROMPT_COMMAND"

    if (( LP_ENABLE_RUNTIME_BELL && _LP_RUNTIME_SECONDS >= LP_RUNTIME_BELL_THRESHOLD ))
    then
        tput bel || tput bl
    fi

    # if change of working directory
    if [[ "${LP_OLD_PWD-}" != "LP:$PWD" ]]; then
        # Update directory icon for MacOS X
        $_LP_TERM_UPDATE_DIR

        # LP_PERM: shows a ":"
        # - colored in green if user has write permission on the current dir
        # - colored in red if not
        # - can set another symbol with LP_MARK_PERM
        if (( LP_ENABLE_PERM )); then
            if [[ -w "${PWD}" ]]; then
                LP_PERM="${LP_COLOR_WRITE}${LP_MARK_PERM}${NO_COL}"
            else
                LP_PERM="${LP_COLOR_NOWRITE}${LP_MARK_PERM}${NO_COL}"
            fi
        fi

        _lp_shorten_path   # set LP_PWD

        LP_OLD_PWD="LP:$PWD"
    fi

    lp_theme_prompt
}

prompt_tag()
{
    if [[ -n "${1-}" ]]; then
        export LP_PS1_PREFIX="$1 "
    else
        export LP_PS1_PREFIX=
    fi
}

# Activate Liquid Prompt
prompt_on() {
    # Reset so all PWD dependent variables are computed after loading
    LP_OLD_PWD=""

    # if Liquid Prompt has not been already set
    if [[ -z "${LP_OLD_PS1-}" ]]; then
        LP_OLD_PS1="$PS1"
        if $_LP_SHELL_bash; then
            LP_OLD_PROMPT_COMMAND="$PROMPT_COMMAND"
            _LP_OLD_SHOPT="$(shopt -p promptvars)"
        else # zsh
            LP_OLD_PROMPT_COMMAND=""
            _LP_ZSH_PROMPT_THEME=""
            if [[ -n "${prompt_theme-}" && "${prompt_theme-}" != off ]]; then
                _LP_ZSH_PROMPT_THEME="$prompt_theme"
                # Disable the prompt to disable its precmd hook
                prompt off
            fi
            _LP_OLD_SETOPT=()
            # Dump option names: echo ${(ko)options}
            for o in promptpercent promptbang promptsubst
            do
                if [[ "${options[$o]}" = on ]]; then
                    _LP_OLD_SETOPT+=$o
                else
                    _LP_OLD_SETOPT+=no$o
                fi
            done
        fi
    fi
    if $_LP_SHELL_bash; then
        # Prevent some cases where the user shoots in his own foot.
        # PROMPT_COMMAND is not exported by default, but some users
        # incorrectly export it from their profile/bashrc (GitHub #450),
        # so we preventively UNexport it.
        # TODO: warn the user if it was exported
        if (( ${BASH_VERSINFO[0]:-0} > 4 || ( ${BASH_VERSINFO[0]:-0} == 4 && ${BASH_VERSINFO[1]:-0} >= 2 ) )); then
            # -g is only available since bash 4.2
            declare -g +x PROMPT_COMMAND
        fi

        # Disable parameter/command expansion from PS1
        shopt -u promptvars
        PROMPT_COMMAND=_lp_set_prompt
        (( LP_DEBUG_TIME )) && PROMPT_COMMAND="time $PROMPT_COMMAND" || true
    else # zsh
        [[ -n "$_LP_ZSH_HOOK" ]] && add-zsh-hook -d precmd $_LP_ZSH_HOOK
        # Set options that affect PS1 evaluation
        # Disable parameter/command expansion; enable percent expansion
        setopt promptpercent nopromptbang nopromptsubst
        # 'time' doesn't seem to work on shell functions: no time output
        #if (( LP_DEBUG_TIME )); then
        #    _lp_main_precmd() {
        #        local TIMEFMT='Liquid Prompt build time: %*E'
        #        time _lp_set_prompt
        #    }
        #    _LP_ZSH_HOOK=_lp_main_precmd
        #else
            _LP_ZSH_HOOK=_lp_set_prompt
        #fi
        add-zsh-hook precmd $_LP_ZSH_HOOK
    fi
}

# Come back to the old prompt
prompt_off()
{
    PS1=$LP_OLD_PS1
    if $_LP_SHELL_bash; then
        eval "$_LP_OLD_SHOPT"
        PROMPT_COMMAND="$LP_OLD_PROMPT_COMMAND"
    else # zsh
        add-zsh-hook -d precmd $_LP_ZSH_HOOK
        setopt ${_LP_OLD_SETOPT}
        (( ${#_LP_ZSH_PROMPT_THEME} )) && prompt $_LP_ZSH_PROMPT_THEME
    fi
}

# Use an empty prompt: just the \$ mark
prompt_OFF()
{
    PS1="$_LP_MARK_SYMBOL "
    if $_LP_SHELL_bash; then
        shopt -u promptvars
        PROMPT_COMMAND="$LP_OLD_PROMPT_COMMAND"
    else # zsh
        add-zsh-hook -d precmd $_LP_ZSH_HOOK
        setopt promptpercent nopromptbang nopromptsubst
    fi
}

# By default, sourcing liquidprompt will activate Liquid Prompt
# Issue #161: do not load if not an interactive shell
if [[ "${1-}" != "--no-activate" && "$-" == *i* && -n "${TERM-}" && "${TERM-}" != dumb ]]; then
    lp_activate
    prompt_on
fi

# vim: set et sts=4 sw=4 tw=120 ft=sh:
